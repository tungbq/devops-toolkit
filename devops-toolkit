#!/bin/bash

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Default configuration options
DOCKER_IMAGE="${DOCKER_IMAGE:-tungbq/devops-toolkit:latest}"
CONFIG_MOUNT_PATH="${CONFIG_MOUNT_PATH:-$HOME/.dtc}"
CONTAINER_NAME="${CONTAINER_NAME:-devops_toolkit}"
CONTAINER_SHELL="${CONTAINER_SHELL:-/bin/bash}"
RUN_MODE="${RUN_MODE:-run}"  # Default to 'run'; change to 'exec' for existing containers
NETWORK="${NETWORK:---net=host}"

if [ -z "$CONTAINER_NAME" ]; then
    log $RED "No CONTAINER_NAME provided"
    exit 1
fi

# Function to check if local image is up-to-date with DockerHub
is_image_up_to_date() {
    local image="$1"
    local repo="${image%:*}"
    local tag="${image#*:}"

    # Get the digest of the local image
    local local_digest=$(docker image inspect --format='{{index .RepoDigests 0}}' "$image" 2>/dev/null | cut -d'@' -f2)

    # Get the digest of the remote image
    local remote_digest=$(docker pull -q "$image" > /dev/null 2>&1 && docker image inspect --format='{{index .RepoDigests 0}}' "$image" | cut -d'@' -f2)

    # Compare digests
    if [ "$local_digest" = "$remote_digest" ]; then
        return 0  # Up-to-date
    else
        return 1  # Not up-to-date
    fi
}

pull_image() {
    local image="$1"

    if [[ "$image" != "sha256:"* ]]; then
        if docker image inspect "$image" >/dev/null 2>&1; then
            if is_image_up_to_date "$image"; then
                log $YELLOW "Image $image is up-to-date. Skipping pull."
            else
                log $BLUE "Local image $image is outdated. Pulling latest version..."
                docker pull "$image" || { log $RED "Failed to pull image $image"; exit 1; }
            fi
        else
            log $BLUE "Pulling image $image..."
            docker pull "$image" || { log $RED "Failed to pull image $image"; exit 1; }
        fi
    fi
}

# Check if the container exists, if not, create it
start_container() {
    local image="$1"
    if ! docker inspect --type=container "$CONTAINER_NAME" > /dev/null 2>&1; then
        log $BLUE "Starting new container with image $image..."
        docker run -d --name "$CONTAINER_NAME" \
            --volume "$PWD:$PWD" \
            --volume "$CONFIG_MOUNT_PATH:/dtc" \
            --volume "$HOME/.ssh:/root/.ssh" \
            --workdir "$PWD" \
            --init \
            --entrypoint tail \
            $NETWORK \
            $DOCKER_ARGS \
            "$image" -f /dev/null > /dev/null || { log $RED "Failed to start container"; exit 1; }
        log $GREEN "Container started successfully"
    else
        log $YELLOW "Container $CONTAINER_NAME already exists"
    fi
}

# Execute a command inside an existing container
exec_in_container() {
    local command="$1"

    local RUN_CMD=$CONTAINER_SHELL

    if [ -n "$command" ]; then
        RUN_CMD+=" -c $command"
    fi

    log $BLUE "Executing command in container $CONTAINER_NAME..."
    docker exec -it "$CONTAINER_NAME" $RUN_CMD || {
        log $RED "Failed to execute command in container $CONTAINER_NAME"; exit 1;
    }
}

# Cleanup function to remove the container
cleanup() {
    log $BLUE "Cleaning up..."
    if docker inspect --type=container "$CONTAINER_NAME" > /dev/null 2>&1; then
        docker stop "$CONTAINER_NAME" > /dev/null
        docker rm "$CONTAINER_NAME" > /dev/null
        log $GREEN "Container $CONTAINER_NAME has been removed."
    else
        log $YELLOW "Container $CONTAINER_NAME does not exist."
    fi
}

# Update function to pull and replace the image
update() {
    local version="$1"
    local new_image

    if [ -z "$version" ]; then
        new_image="${DOCKER_IMAGE%:*}:latest"
        log $BLUE "Updating to the latest version..."
    else
        new_image="${DOCKER_IMAGE%:*}:$version"
        log $BLUE "Updating to version $version..."
    fi

    # Check if the new image is different from the current one
    if [ "$new_image" == "$DOCKER_IMAGE" ]; then
        if is_image_up_to_date "$new_image"; then
            log $YELLOW "The specified image ($new_image) is already in use and up-to-date. No update needed."
            return
        else
            log $BLUE "The specified image ($new_image) is in use but outdated. Updating..."
        fi
    fi

    # Pull the new image (if it doesn't exist locally or is outdated)
    pull_image "$new_image"

    # Stop and remove the existing container
    cleanup

    # Update the DOCKER_IMAGE variable
    DOCKER_IMAGE="$new_image"

    # Start a new container with the updated image
    start_container "$DOCKER_IMAGE"

    log $GREEN "Update completed successfully. New image: $DOCKER_IMAGE"
}

# Usage function
usage() {
    log $BLUE "Usage: $0 [run|exec|cleanup|update] [command|version]"
    echo "  run: Start a new container and run a command"
    echo "  exec: Execute a command in an existing container"
    echo "  cleanup: Remove the container"
    echo "  update [version]: Update the container image. If version is omitted, updates to latest."
}

# Main logic
case "$1" in
    run)
        RUN_MODE="run"
        shift
        log $BLUE "Running in 'run' mode..."
        pull_image "$DOCKER_IMAGE"
        start_container "$DOCKER_IMAGE"
        exec_in_container "$@"
        ;;
    exec)
        RUN_MODE="exec"
        shift
        log $BLUE "Running in 'exec' mode..."
        exec_in_container "$@"
        ;;
    cleanup)
        cleanup
        exit 0
        ;;
    update)
        shift
        update "$1"
        exit 0
        ;;
    *)
        log $RED "Invalid command: $1"
        usage
        exit 1
        ;;
esac
